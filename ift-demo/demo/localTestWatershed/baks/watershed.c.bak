/*
    Copyright (C) <2010> <Alexandre Xavier Falcão and Thiago Vallin Spina>

    This file is part of IFT-demo.

    IFT-demo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    IFT-demo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with IFT-demo.  If not, see <http://www.gnu.org/licenses/>.

    please see full copyright in COPYING file.
    -------------------------------------------------------------------------

    written by A.X. Falc�o <afalcao@ic.unicamp.br> and by T.V. Spina
    <tvspina@liv.ic.unicamp.br>, 2010

*/

#include "ift.h"
#define DEVICE CL_DEVICE_TYPE_GPU
#define NLOOP 1

/* Papers related to this program:

@incollection{Lotufo00,
 author    = "R.A. Lotufo and A.X. Falc{\~{a}}o",
 booktitle = "Mathematical Morphology and its Applications to Image and Signal Processing (ISMM)",
 title     = "The ordered queue and the optimality of the watershed approaches",
 publisher = "Kluwer",
 volume    = "18",
 month     = "Jun",
 pages     = "341--350",
 year      = "2000"
}

@article{Miranda09b,
author = "P.A.V. Miranda and A.X. Falc{\~{a}}o",
title = "Links Between Image Segmentation Based on Optimum-Path Forest and Minimum Cut in Graph",
journal = "Journal of Mathematical Imaging and Vision",
pages = {128--142},
volume = 35,
number = "2",
publisher = {Springer},
month = "Oct",
year = {2009},
note = "doi:10.1007/s10851-009-0159-9"
}

@inproceedings{Audigier07,
author = "R. Audigier and R.A. Lotufo",
title = "Watershed by Image Foresting Transform, tie-zone, and theoretical relationship with other watershed definitions",
booktitle = "Mathematical Morphology and its Applications to Signal and Image Processing (ISMM)",
address = "Rio de Janeiro, RJ",
publisher = "MCT/INPE",
pages = "277--288",
month = "Oct",
year = 2007
}

*/

bool vazio (cl_int Mask[], cl_int n) {
    cl_int i;
    for (i = 0; i < n; i++) {
        if (Mask[i] == true)
            return false;
    }
    return true;
}

void CL_CALLBACK contextCallback (
        const char *errInfo,
        const void *private_info,
        size_t cb,
        void *user_data			) {
    printf ( "An error happenned during context use: %s\n", errInfo );
    exit(1);
}

void SetLabelIterative (cl_int* pred, cl_int* label, cl_int n) {
    int pd;
    int i = 0, j;

    for ( i = 0; i < n; i++ ) {
        pd = i;
        j = 0;

        while ( pred [pd] >= 0 && j < n ) {
            pd = pred [ pd ];
            j++;
        }
        if ( pred [pd] == -1 )
            label [i] = label [ pd ];
    }
}

// Watershed from binary marker

Image *Watershed(Image *img, Set *Obj, Set *Bkg)
{
  timer    *t1=NULL,*t2=NULL;
  AdjRel *A=NULL;
  GQueue *Q=NULL;
  Image  *cost=NULL,*label=NULL;
  Pixel   u,v;
  int     i,p,q,n,tmp,Cmax=MaximumValue(img);
  Set    *S;

  cost  = CreateImage(img->ncols,img->nrows);
  label = CreateImage(img->ncols,img->nrows);
  n     = img->ncols*img->nrows;
  Q     = CreateGQueue(Cmax+1,n,cost->val);
  A     = Circular(1.5);
    /*--------------------------------------------------------*/
    /* OpenCL variables --------------------------------------*/
    timer    *tS1=NULL,*tS2=NULL;
    FILE* fp;
    char* source_str; 
    size_t source_size;
    cl_int errNum;
    cl_uint nPlataformas;
    cl_uint nDispositivos;
    cl_platform_id *listaPlataformaID;
    cl_device_id *listaDispositivoID;
    cl_context contexto = NULL;
    cl_command_queue fila;
    cl_program programa0, programa, programa2, programa3;
    cl_kernel kernel0, kernel, kernel2, kernel3;
    cl_event evento, evento0, evento1, evento2, evento3;

    cl_mem  costBuffer, costvalBuffer, costtbrowBuffer,
            numVbuffer, SEMbuffer, extraBuffer,
            Abuffer, Adxbuffer, Adybuffer,
            imgtbrowBuffer, labelvalBuffer, labeltbrowBuffer,
            Mbuffer, MvalBuffer, MtbrowBuffer,
            /*
            Ubuffer, Ulabelbuffer,
            Cbuffer, Clabelbuffer,
            UPredbuffer, CPredbuffer,
            */
            IBuffer, IvalBuffer, imgValBuffer,
            labelBuffer, predBuffer,
            cacheBuffer, cache2Buffer, cache3Buffer;


    /*--------------------------------------------------------*/

    /* Preparing device for OpenCL program */
    errNum = clGetPlatformIDs(0, NULL, &nPlataformas);
    checkErr( (errNum != CL_SUCCESS) ? errNum : 
            (nPlataformas <= 0 ? -1 : CL_SUCCESS),
            "clGetPlataformsIDs");
    // Se n�o houve erro, alocar mem�ria para cl_platform_id
    listaPlataformaID = (cl_platform_id *)alloca(sizeof(cl_platform_id)*nPlataformas);
    // Atribuindo uma plataforma ao listaPlataformaID
    errNum = clGetPlatformIDs(nPlataformas, listaPlataformaID, NULL);
    //std::cout << "#Plataformas: " << nPlataformas << std::endl;
    printf ( "#Platforms: %d\n", nPlataformas );
    checkErr(
            (errNum != CL_SUCCESS) ? errNum :
            (nPlataformas <= 0 ? -1 : CL_SUCCESS),
            "clGetPlatformIDs");

    cl_uint j;
    for (j=0; j < nPlataformas; j++) {
        // Atribuindo o n�mero de dispositivos de GPU a nDispositivos
        errNum = clGetDeviceIDs (	listaPlataformaID[j],
                //								CL_DEVICE_TYPE_ALL,
                DEVICE,
                0,
                NULL,
                &nDispositivos		);
        if (errNum != CL_SUCCESS && errNum != CL_DEVICE_NOT_FOUND) {
            infoPlataforma(listaPlataformaID, j);
            checkErr (errNum, "clGetDeviceIDs");
        }
        // Conferindo se h� dispositivos de CPU
        else if (nDispositivos > 0) {
            // Atribuindo um dispositivo a uma listaDispositivoID
            listaDispositivoID = (cl_device_id *)alloca(sizeof(cl_device_id)*nDispositivos);

            errNum = clGetDeviceIDs (	
                    listaPlataformaID[j],
                    //									CL_DEVICE_TYPE_ALL,
                    DEVICE,
                    nDispositivos,
                    &listaDispositivoID[0],
                    NULL);
            checkErr(errNum, "clGetPlatformIDs");
            break;
        }
    }

    // Crindo um contexto no dispositivo/plataforma selecionada
    //std::cout << "Adicionando dispositivos OpenCL de numero " << i << std::endl;
    printf ( " Adding OpenCL devices -- number %d\n", j );
    infoPlataforma(listaPlataformaID, j);
    cl_context_properties propContexto[] = {
        CL_CONTEXT_PLATFORM,
        (cl_context_properties)listaPlataformaID[j],
        0
    };

    contexto = clCreateContext(
            propContexto,
            nDispositivos,
            listaDispositivoID,
            &contextCallback,
            NULL,
            &errNum			);

    checkErr(errNum, "clCreateContext");

    fp = fopen("init.cl", "r");
    if (!fp) {
        fprintf(stderr, "Failed to load kernel.\n");
        exit(1);
    }
    source_str = (char*)alloca(MAX_SOURCE_SIZE);
    source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);
    fclose(fp);

    programa0 = clCreateProgramWithSource(
            contexto, 
            1, 
            (const char **)&source_str,
            (const size_t *)&source_size, 
            &errNum);
    checkErr(errNum, "clCreateProgramWithSource 0");

    fp = fopen("dijkstra.cl", "r");
    if (!fp) {
        fprintf(stderr, "Failed to load kernel.\n");
        exit(1);
    }
    source_str = (char*)alloca(MAX_SOURCE_SIZE);
    source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);
    fclose(fp);

    //    printf ( "Source code of kernel 1:\n%s\n\n", source_str );

    programa = clCreateProgramWithSource(
            contexto, 
            1, 
            (const char **)&source_str,
            (const size_t *)&source_size, 
            &errNum);
    checkErr(errNum, "clCreateProgramWithSource");

    fp = fopen("kernel3.cl", "r");
    if (!fp) {
        fprintf(stderr, "Failed to load kernel3.\n");
        exit(1);
    }
    source_str = (char*)alloca(MAX_SOURCE_SIZE);
    source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);
    fclose(fp);

    programa3 = clCreateProgramWithSource(contexto, 1, (const char **)&source_str,
            (const size_t *)&source_size, &errNum);

    printf ( "Compiling the kernel 0 ... \r" );
    errNum = clBuildProgram (
            programa0,
            nDispositivos,
            listaDispositivoID,
            "-cl-fast-relaxed-math -cl-mad-enable",
            NULL,
            NULL);

    printf ( "kernel0 compiled!          \n" );
    if (errNum != CL_SUCCESS) { 		// Verificando se houve erro
        // Determinando o motivo do erro
        char logCompilacao[16384];
        clGetProgramBuildInfo (
                programa0,
                listaDispositivoID[0],
                CL_PROGRAM_BUILD_LOG,
                sizeof(logCompilacao),
                logCompilacao,
                NULL);

        //std::cerr << "Erro no kernel: " << std::endl;
        printf ( " Build error : %s\n", logCompilacao );

        //		std::cerr << logCompilacao;
        checkErr(errNum, "clBuildProgram");
    }

    printf ( "Compiling the kernel 1 ... \r" );
    errNum = clBuildProgram (
            programa,
            nDispositivos,
            listaDispositivoID,
            "-cl-fast-relaxed-math -cl-mad-enable",
            NULL,
            NULL);

    printf ( "kernel1 compiled!         \n" );

    if (errNum != CL_SUCCESS) { 		// Verificando se houve erro
        char logCompilacao[16384];
        clGetProgramBuildInfo (
                programa,
                listaDispositivoID[0],
                CL_PROGRAM_BUILD_LOG,
                sizeof(logCompilacao),
                logCompilacao,
                NULL);

        printf ( " Build error : %s\n", logCompilacao );
        checkErr(errNum, "clBuildProgram");
    }

    errNum = clBuildProgram (
            programa3,
            nDispositivos,
            listaDispositivoID,
            NULL,
            NULL,
            NULL);

    printf ( "kernel3 compiled! \n" );

    if (errNum != CL_SUCCESS) { 		// Verificando se houve erro
        char logCompilacao[16384];
        clGetProgramBuildInfo (
                programa3,
                listaDispositivoID[0],
                CL_PROGRAM_BUILD_LOG,
                sizeof(logCompilacao),
                logCompilacao,
                NULL);
        printf ( " Build error : %s\n", logCompilacao );
        checkErr(errNum, "clBuildProgram");
    }

    printf ( "KERNEL 0\n" );
    // Criando o objeto do Kernel
    kernel0 = clCreateKernel (
            programa0,
            "initCache",
            &errNum);
    checkErr(errNum, "clCreateKernel0");

    printf ( "KERNEL 1\n" );
    // Criando o objeto do Kernel
    kernel = clCreateKernel (
            programa,
            "dijkstra",
            &errNum);
    checkErr(errNum, "clCreateKernel1");

    printf ( "KERNEL 3\n" );
    // Criando o objeto do Kernel3
    kernel3 = clCreateKernel (
            programa3,
            "dijkstra3",
            &errNum);
    checkErr(errNum, "clCreateKernel3");

    int N = n, Nc = img->ncols, Nr = img->nrows;
    int t = 0;
    while ( N > 0 ) {
        N >>= 1;
        t++;
    }
    N = 1 << t;
    t = 0;
    while ( Nc > 0 ) {
        Nc >>= 1;
        t++;
    }
    Nc = 1 << t;
    t = 0;
    while ( Nr > 0 ) {
        Nr >>= 1;
        t++;
    }
    Nr = 1 << t;

    printf ("n=%d ... N=%d (2^%d)##\n", n, N, t);
    printf ("ncols=%d nrows=%d ... Nc=%d Nr=%d##\n", img->ncols,
                                    img->nrows, Nc, Nr);


    printf ("-- ");
    cl_int* Mask = (cl_int *) malloc (N * sizeof ( cl_int ) );
    cl_int* pred = (cl_int *) malloc (N * sizeof ( cl_int ) );
    /*
    cl_int* CostCost = (cl_int *) malloc (n * sizeof ( cl_int ) );
    cl_int* UpdateCost = (cl_int *) malloc (n * sizeof ( cl_int ) );
    cl_int* Clabel = (cl_int *) malloc (n * sizeof ( cl_int ) );
    cl_int* Ulabel = (cl_int *) malloc (n * sizeof ( cl_int ) );
    cl_int* UpdatePred = (cl_int *) malloc (n * sizeof ( cl_int ) );
    cl_int* CostPred = (cl_int *) malloc (n * sizeof ( cl_int ) );
    */
    static volatile cl_int semaforo = 0;
    cl_int extra = n;
    cl_int16* cache = (cl_int16 *) malloc ( sizeof (cl_int16) * N );

    memset (Mask, 0, N*4);
    memset (pred, 0, n*4);

  /* Trivial path initialization */

    for (p=0; p < n; p++){
        cost->val[p] =INT_MAX;
        pred[p] = -2;
    }
    S = Obj;
    while(S != NULL){
        p=S->elem;
        label->val[p]=1;
        cost->val[p]=0;
        pred[p] = -1;
        //InsertGQueue(&Q,p);
        Mask [ p ] = true;
        S = S->next;
    }
    S = Bkg;
    while(S != NULL){
        p=S->elem;
        label->val[p]=0;
        cost->val[p]=0;
        pred[p] = -1;
        //InsertGQueue(&Q,p);
        Mask [ p ] = true;
        S = S->next;
    }

// This describes the format of the image data.
    cl_image_format format;
    format.image_channel_order = CL_INTENSITY;
    format.image_channel_data_type = CL_UNSIGNED_INT32;
 
    int width = img->ncols;
    int height = img->nrows;
    cl_mem input_image = clCreateImage2D(
                                           contexto,
                                           CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                           &format,
                                           img->ncols,
                                           img->nrows,
                                           0,
                                           img->val,
                                           &errNum
                                           );
    checkErr ( errNum, "Creating Input Image" );

    cl_mem output_image = clCreateImage2D( contexto,
                                           CL_MEM_WRITE_ONLY | CL_MEM_COPY_HOST_PTR,
                                           &format,
                                           img->ncols,
                                           img->nrows,
                                           0,
                                           img->val,
                                           &errNum
                                           );
    checkErr ( errNum, "Creating Output Image" );

    cl_sampler sampler = clCreateSampler (  contexto,
                                            CL_FALSE,
                                            CL_ADDRESS_CLAMP,
                                            CL_FILTER_NEAREST,
                                            &errNum );
    checkErr ( errNum, "Creating Sampler" );
                                            
    cacheBuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, 
            sizeof(cl_int16) * N,
            cache,
            &errNum);
    checkErr(errNum, "clCreateBuffer(cache)");

    IBuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
            sizeof ( Image ),
            img,
            &errNum);
    checkErr(errNum, "clCreateBuffer(M_valBuffer)");

    imgtbrowBuffer= clCreateBuffer (
            contexto,
            CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
            img->nrows * ( sizeof ( cl_int ) ),
            img->tbrow,
            &errNum);
    checkErr(errNum, "clCreateBuffer(img)");

    IvalBuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
            //Cmax+1,
            n * ( sizeof(cl_int) ),
            img->val,
            &errNum);
    checkErr(errNum, "clCreateBuffer(M_valBuffer)");

    imgValBuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
            //Cmax+1,
            n * ( sizeof(cl_int) ),
            img->val,
            &errNum);
    checkErr(errNum, "clCreateBuffer(imgValBuffer)");

    costBuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
            //Cmax+1,
            n * ( sizeof(cl_int) ),
            cost->val,
            &errNum);
    checkErr(errNum, "clCreateBuffer(costBuffer)");

    labelBuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
            //Cmax+1,
            n * ( sizeof(cl_int) ),
            label->val,
            &errNum);
    checkErr(errNum, "clCreateBuffer(labelBuffer)");

    predBuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
            //Cmax+1,
            N * ( sizeof(cl_int) ),
            pred,
            &errNum);
    checkErr(errNum, "clCreateBuffer(predBuffer)");

    Mbuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
            //Cmax+1,
            N * (sizeof(cl_int)),
            Mask,
            &errNum);
    checkErr(errNum, "clCreateBuffer(M_buffer)");

    Abuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
            sizeof( cl_int * ),
            &(A->n),
            &errNum);
    checkErr(errNum, "clCreateBuffer(A)");

    Adxbuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
            A->n * sizeof( cl_int ),
            A->dx,
            &errNum);
    checkErr(errNum, "clCreateBuffer(A)");

    Adybuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
            A->n * sizeof( cl_int ),
            A->dy,
            &errNum);
    checkErr(errNum, "clCreateBuffer(A)");

    SEMbuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
            sizeof(cl_int),
            (void *)&semaforo,
            &errNum);
    checkErr(errNum, "clCreateBuffer(semaforo)");

    extraBuffer = clCreateBuffer (
            contexto,
            CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
            sizeof(cl_int),
            &extra,
            &errNum);
    checkErr(errNum, "clCreateBuffer(extra)");

    fila = clCreateCommandQueue (
            contexto, 
            listaDispositivoID[0],
            CL_QUEUE_PROFILING_ENABLE,
            &errNum);
    checkErr(errNum, "clCreateCommandQueue");

    // Setando os argumentos da fun��o do Kernel

    errNum = clSetKernelArg(kernel0, 0, sizeof(cl_mem), &IBuffer);
    errNum |= clSetKernelArg(kernel0, 1, sizeof(cl_mem), &IvalBuffer);
    errNum |= clSetKernelArg(kernel0, 2, sizeof(cl_mem), &imgtbrowBuffer);
    errNum |= clSetKernelArg(kernel0, 3, sizeof(cl_mem), &Abuffer);
    errNum |= clSetKernelArg(kernel0, 4, sizeof(cl_mem), &Adxbuffer);
    errNum |= clSetKernelArg(kernel0, 5, sizeof(cl_mem), &Adybuffer);
    errNum |= clSetKernelArg(kernel0, 6, sizeof(cl_mem), &SEMbuffer);
    errNum |= clSetKernelArg(kernel0, 7, sizeof(cl_mem), &extraBuffer);
    errNum |= clSetKernelArg(kernel0, 8, sizeof(cl_mem), &cacheBuffer);
    /*
    errNum |= clSetKernelArg(kernel0, 9, sizeof(cl_mem), &input_image);
    errNum |= clSetKernelArg(kernel0, 10, sizeof(cl_sampler), &sampler);
    */
    checkErr(errNum, "clSetKernelArg at Kernel 0");

    // Kernel 1: Dijkstra' kernel
    errNum = clSetKernelArg(kernel, 0, sizeof(cl_mem), &IBuffer);
    errNum |= clSetKernelArg(kernel, 1, sizeof(cl_mem), &IvalBuffer);
    errNum |= clSetKernelArg(kernel, 2, sizeof(cl_mem), &Adxbuffer);
    errNum |= clSetKernelArg(kernel, 3, sizeof(cl_mem), &Adybuffer);
    errNum |= clSetKernelArg(kernel, 4, sizeof(cl_mem), &Mbuffer);
    errNum |= clSetKernelArg(kernel, 5, sizeof(cl_mem), &costBuffer);
    errNum |= clSetKernelArg(kernel, 6, sizeof(cl_mem), &predBuffer);
    errNum |= clSetKernelArg(kernel, 7, sizeof(cl_mem), &imgValBuffer);
    //errNum |= clSetKernelArg(kernel, 5, sizeof(cl_mem), &CPredbuffer);
    errNum |= clSetKernelArg(kernel, 8, sizeof(cl_mem), &SEMbuffer);
    errNum |= clSetKernelArg(kernel, 9, sizeof(cl_mem), &extraBuffer);
    errNum |= clSetKernelArg(kernel, 10, sizeof(cl_mem), &cacheBuffer);
    /*
    errNum |= clSetKernelArg(kernel, 11, sizeof(cl_mem), &input_image);
    errNum |= clSetKernelArg(kernel, 12, sizeof(cl_sampler), &sampler);
    */
    checkErr(errNum, "clSetKernelArg at Kernel 1");

    //errNum = clSetKernelArg(kernel3, 0, sizeof(cl_mem), &Mbuffer);
    //errNum |= clSetKernelArg(kernel3, 1, sizeof(cl_mem), &Cbuffer);
//    errNum |= clSetKernelArg(kernel3, 2, sizeof(cl_mem), &Ubuffer);
    errNum |= clSetKernelArg(kernel3, 0, sizeof(cl_mem), &labelBuffer);
    //errNum |= clSetKernelArg(kernel3, 4, sizeof(cl_mem), &Ulabelbuffer);
    //errNum |= clSetKernelArg(kernel3, 5, sizeof(cl_mem), &UPredbuffer);
    errNum |= clSetKernelArg(kernel3, 1, sizeof(cl_mem), &predBuffer);
    errNum |= clSetKernelArg(kernel3, 2, sizeof(cl_mem), &SEMbuffer);
    errNum |= clSetKernelArg(kernel3, 3, sizeof(cl_mem), &extraBuffer);
    checkErr(errNum, "clSetKernelArg at Kernel 3");

    // Definindo o n�mero de work-items globais e locais
    const size_t globalWorkSize[1] = { N };
    const size_t localWorkSize[1] = { 256 };
    const size_t globalWorkSize2[2] = { N , 8 };
    const size_t localWorkSize2[2] = { 1024, 1 };
    const size_t globalWorkSize3[2] = { Nr , Nc };
    const size_t localWorkSize3[2] = { 32, 32 };

    cl_int vez = 0;
    double run_time_k0 = 0;
    double run_time_k1 = 0;
    double run_time_k2 = 0;
    double run_time_k3 = 0;
    cl_ulong ev_start_time=(cl_ulong)0;     
    cl_ulong ev_end_time=(cl_ulong)0;
    gettimeofday(tS1, NULL);
    // releituraFeita e um evento que sincroniza a atualizacao feita
    // por cada chamada aos kernels

    cl_event releituraFeita;
    errNum = clEnqueueReadBuffer(fila, Mbuffer, CL_FALSE, 0, 
            sizeof(cl_int) * n, Mask, 0, NULL, &releituraFeita);
    checkErr(errNum, CL_SUCCESS);
    clWaitForEvents(1, &releituraFeita);

    printf ( "Caching neighboorhood..." );
    errNum = clEnqueueNDRangeKernel (
            fila,
            kernel0,
            1,
            NULL,
            globalWorkSize,
            localWorkSize,
            0,
            NULL,
            &evento0);
    checkErr(errNum, "clEnqueueNDRangeKernel 0");

    clFinish(fila);

    errNum |= clGetEventProfilingInfo(evento0, 
            CL_PROFILING_COMMAND_START, sizeof(cl_ulong),
            &ev_start_time, NULL);

    errNum |= clGetEventProfilingInfo(evento0, 
            CL_PROFILING_COMMAND_END, sizeof(cl_ulong), 
            &ev_end_time, NULL);

    checkErr(errNum, "Error Profiling cache");

    run_time_k0 += (double)(ev_end_time - ev_start_time)/1e6; // in msec


    printf ( "\nEntering in loop...\n" );

    while(!vazio(Mask, n)) {

        //for ( i = 0; i < NLOOP; i++) {
            // Enfileirando o Kernel para execu��o atrav�s da matriz
            errNum = clEnqueueNDRangeKernel (
                    fila,
                    kernel,
                    1,
                    NULL,
                    globalWorkSize,
                    localWorkSize,
                    0,
                    NULL,
                    &evento1);
            checkErr(errNum, "clEnqueueNDRangeKernel 1");

            clFinish(fila);

            /*
            // Enfileirando o Kernel2 para execu��o atrav�s da matriz
            errNum = clEnqueueNDRangeKernel (
                    fila,
                    kernel2,
                    1,
                    NULL,
                    globalWorkSize,
                    localWorkSize,
                    0,
                    NULL,
                    &evento2);
            checkErr(errNum, "clEnqueueNDRangeKernel2");
            clFinish(fila);
            */
            errNum |= clGetEventProfilingInfo(evento1, 
                    CL_PROFILING_COMMAND_START, sizeof(cl_ulong),
                    &ev_start_time, NULL);

            errNum |= clGetEventProfilingInfo(evento1, 
                    CL_PROFILING_COMMAND_END, sizeof(cl_ulong), 
                    &ev_end_time, NULL);

            checkErr(errNum, "Error Profiling Kernel 1");
            run_time_k1 += (double)(ev_end_time - ev_start_time)/1e6; // in msec
            /*

            errNum |= clGetEventProfilingInfo(evento2, 
                    CL_PROFILING_COMMAND_START, sizeof(cl_ulong),
                    &ev_start_time, NULL);

            errNum |= clGetEventProfilingInfo(evento2, 
                    CL_PROFILING_COMMAND_END, sizeof(cl_ulong), 
                    &ev_end_time, NULL);

            checkErr(errNum, "Error Profiling");
            run_time_k2 += (double)(ev_end_time - ev_start_time)/1e6; // in msec
            */
        //}

        errNum = clEnqueueReadBuffer(fila, Mbuffer, CL_FALSE, 0, 
                sizeof(cl_int) * n, Mask, 0, NULL, &releituraFeita);
        checkErr(errNum, "Reading Mask");
        clWaitForEvents(1, &releituraFeita);

    }
    errNum = clReleaseMemObject ( Mbuffer );
    errNum |= clReleaseMemObject ( cacheBuffer );
    errNum |= clReleaseMemObject ( IBuffer );
    errNum |= clReleaseMemObject ( costBuffer );
    checkErr(errNum, "clRelease");

    errNum = clEnqueueReadBuffer(fila, predBuffer, CL_TRUE, 0, 
            sizeof(cl_int) * N, pred, 0, NULL, NULL);
    checkErr(errNum, CL_SUCCESS);

    fp = fopen ("diffPred.txt", "w");
    for ( i = 0; i < N; i++ ) {
        if ( pred[i] >= 0 )
            fprintf ( fp, "%d ", pred[i] - i );
        else
            fprintf ( fp, "-1 " );
        if ( i % 24 == 0 ) 
            fprintf ( fp, "\n" );
    }
    fclose (fp);
/*
*/
            errNum = clEnqueueNDRangeKernel (
                    fila,
                    kernel3,
                    1,
                    NULL,
                    globalWorkSize2,
                    localWorkSize2,
                    0,
                    NULL,
                    &evento2);
            checkErr(errNum, "clEnqueueNDRangeKernel 3");

    printf ( "Reading buffer...\n" );
    errNum = clEnqueueReadBuffer(   fila, 
        labelBuffer, 
        CL_FALSE, 
        0, 
        sizeof(cl_int) * n, 
        label->val,
        0, 
        NULL, 
        NULL    );
    checkErr ( errNum, "Reading label" );
    printf ( "\r\rRead!\n" );
    /*
    errNum = clEnqueueReadBuffer(   fila, 
        predBuffer, 
        CL_FALSE, 
        0, 
        sizeof(cl_int) * n, 
        pred,
        0, 
        NULL, 
        NULL    );
    checkErr ( errNum, "Reading pred" );
    */

    clFinish ( fila );


 //   SetLabelIterative ( pred, label->val, n );
    printf ( "Labeled!\n" );

            errNum |= clGetEventProfilingInfo(evento2, 
                    CL_PROFILING_COMMAND_START, sizeof(cl_ulong),
                    &ev_start_time, NULL);

            errNum |= clGetEventProfilingInfo(evento2, 
                    CL_PROFILING_COMMAND_END, sizeof(cl_ulong), 
                    &ev_end_time, NULL);

            checkErr(errNum, "Error Profiling Kernel 3");
            run_time_k3 += (double)(ev_end_time - ev_start_time)/1e6; // in msec

    printf ( "Exiting from loop...\n" );
    printf ( "Time K0: %lf ms\n", run_time_k0 );
    printf ( "Time K1: %lf ms\n", run_time_k1 );
    printf ( "Time K3: %lf ms\n", run_time_k3 );
    printf ( "Total Parallel Time: %lf ms\n", run_time_k3+run_time_k1+run_time_k0 );

    /*
    errNum = clEnqueueReadBuffer(   fila, 
        imgValBuffer, 
        CL_TRUE, 
        0, 
        sizeof(cl_int) * n, 
        F->V->val,
        0, 
        NULL, 
        NULL    );

    checkErr ( errNum, "Reading imgVal" );
    errNum = clEnqueueReadBuffer(   fila, 
        costBuffer, 
        CL_TRUE, 
        0, 
        sizeof(cl_int) * n, 
        F->R->val,
        0, 
        NULL, 
        NULL    );

    checkErr ( errNum, "Reading cost" );
*/


  /* Path propagation */

  /*
  while (!EmptyGQueue(Q)){
    p   = RemoveGQueue(Q);
    u.x = p%img->ncols;
    u.y = p/img->ncols;
    for (i=1; i < A->n; i++) {
      v.x = u.x + A->dx[i];
      v.y = u.y + A->dy[i];
      if (ValidPixel(img,v.x,v.y)){
	q   = v.x + img->tbrow[v.y];
	if (cost->val[p] < cost->val[q]){

	  tmp = MAX(cost->val[p] , img->val[q]);
	  if (tmp < cost->val[q]){
	    if (cost->val[q]!=INT_MAX)
	      RemoveGQueueElem(Q,q);
	    cost->val[q] =tmp;
	    label->val[q]=label->val[p];
	    InsertGQueue(&Q,q);
	  }
	}

      }
    }
  }
*/

  fprintf(stdout,"Processing time in %f ms\n",CTime(t1,t2));

  DestroyGQueue(&Q);
  DestroyImage(&cost);
  DestroyAdjRel(&A);

  return(label);
}

int main(int argc, char **argv)
{
  Image    *img=NULL,*grad=NULL;
  Image    *label=NULL;
  CImage   *cimg=NULL;
  Set      *Obj=NULL,*Bkg=NULL;
  char     outfile[100];
  char     *file_noext;
  /*--------------------------------------------------------*/

  void *trash = malloc(1);
  struct mallinfo info;
  int MemDinInicial, MemDinFinal;
  free(trash);
  info = mallinfo();
  MemDinInicial = info.uordblks;

  /*--------------------------------------------------------*/

  if (argc!=4){
    fprintf(stderr,"Usage: watershed <image.pgm> <gradient.pgm> <seeds.txt>\n");
    fprintf(stderr,"image.pgm: image to overlay the watershed lines on it\n");
    fprintf(stderr,"gradient.pgm: gradient image to compute the watershed segmentation\n");
    fprintf(stderr,"seeds.txt: seed pixels\n");
    exit(-1);
  }

  img   = ReadImage(argv[1]);
  grad  = ReadImage(argv[2]);
  ReadSeeds(argv[3],&Obj,&Bkg);

  file_noext = strtok(argv[1],".");


  label = Watershed(grad,Obj,Bkg);


  cimg = DrawLabeledRegions(img,label);
  sprintf(outfile,"%s_result.ppm",file_noext);
  WriteCImage(cimg,outfile);
  DestroyImage(&grad);
  DestroyImage(&img);
  DestroyImage(&label);
  DestroyCImage(&cimg);
  DestroySet(&Obj);
  DestroySet(&Bkg);

  /* ---------------------------------------------------------- */

  info = mallinfo();
  MemDinFinal = info.uordblks;
  if (MemDinInicial!=MemDinFinal)
    printf("\n\nDinamic memory was not completely deallocated (%d, %d)\n",
	   MemDinInicial,MemDinFinal);

  return(0);
}
